## 线程安全性的表现方面  
原子性  
## Atomic包  
AtomicXXX：CAS、Unsafe.compareAndSwapInt  
## CAS原理  
CAS的底层实现是在一个死循环中不断尝试修改目标值，直到修改成功  

如果竞争不激烈时，修改成功概率很高，反之，修改失败的概率很高，在大量失败的情况下会进行多次的循环尝试，性能会受到一定影响  
对于普通类型的long、double变量，JVM允许将64位的读/写操作，拆分成两个32位的操作  

## LongAdder的实现思想  
它将热点数据分离，比如将AtomicLong的内部核心数据`value`分离成一个数组，每个线程访问时通过hash等算法，映射到其中的一个数字进行计数，而最终结果是这个数组的求和累加  
其中热点数据value会被分离成多个单元的`Cell`，每个Cell独立维护内部的值，当前对象的值由所有的cell累计合成，这样热点就进行了有效的分离，并提高了并行度  

LongAdder在AtomicLong的基础上，将单点的更新压力分散到各个节点上  
在低并发的时候，通过对`base`的直接更新，可以很好地保障和Atomic的性能基本一致；  
在高并发时则通过分散提高了性能  
## LongAdder的缺点：
在统计时如果有并发更新，可能会导致统计数据有误差  
实际使用中，在高并发情况下可以优先使用LongAdder  
在线程竞争很低的情况下，使用Atomic更简单，直接，并且效率高一点  
其他情况，比如序号生成，这种情况下需要准确的数值，全局唯一的AtomicLong才是正确的选择  
## 