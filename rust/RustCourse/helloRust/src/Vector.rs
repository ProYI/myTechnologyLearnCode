/**
动态数组 Vector

允许存储多个值，这些值在内存中一个紧挨着另一个排列，因此访问其中某个元素的成本非常低

动态数组只能存储相同类型的元素
如果想存储不同类型的元素，可以使用枚举类型或者特征对象

当需要一个列表，里面都是相同类型的数据时，动态数组非常有用
 */
pub fn vector_demo() {

    // 创建动态数组
    // v需要显示声明为i32的原因是 无法从new()中推导具体类型
    let v : Vec<i32> = Vec::new();

    // 通过增加的元素 可以推测具体类型
    let mut v = Vec::new();
    v.push(1);

    // Vec::with_capacity(capacity) 指定存储的元素个数，避免扩容的内存分配和拷贝，提升性能


    // 使用宏 vec! 来创建数组，可以在创建同时给予初始化值
    let v2 = vec![1,2,3];

    // 更新Vector 与其它类型一样，必须将动态数组声明为 mut 后，才能进行修改
    // 向数组尾部添加元素
    // v1.push(1);

    // Vector 类型在超出作用域范围后，会被自动删除

    // 读取元素
    // 读取指定位置的元素有两种方式 1. 下标索引 2. get方法
    let v3 = vec![1, 2, 3, 4, 5];

    // 索引下标都是从 0 开始
    let third: &i32 = &v3[2];
    println!("第三个元素是 {}", third);

    // get(2) 也是访问第三个元素，但是它返回了 Option<&T>，因此还需要额外的 match 来匹配解构出具体的值
    match v3.get(2) {
        Some(third) => println!("第三个元素是 {}", third),
        None => println!("根本没有第三个元素！"),
    }

    // 下标索引与 .get 的区别
    // &v3[100] 的访问方式会导致程序报错退出，因为发生了数组越界访问
    // v3.get 不会，它在内部做了处理，有值的时候返回 Some(T)，无值的时候返回 None，因此 v.get 的使用方式非常安全
    // 为什么不统一用get  --->  多种选择，而且在能保证不越界的情况下，下标更加简洁，并且没有匹配的性能损失

    // 同时借用多个数组元素
    // let mut v4 = vec![1, 2, 3, 4, 5];
    // let first = &v4[0];
    // v4.push(6);
    // println!("The first element is: {}", first);
    // 编译器报错， v4.push 进行了可变借
    // first 这个不可变借用在可变借用 v.push 后被使用,
    // 按理说，两个引用不应该互相影响的：一个是查询元素，一个是在数组尾部插入元素，完全不相干的操作，为何编译器要这么严格？
    // 原因在于：数组的大小是可变的，当旧数组的大小不够用时，Rust 会重新分配一块更大的内存空间，然后把旧数组拷贝过来
    // 之前的引用显然会指向一块无效的内存

    // 迭代遍历 Vector 中的元素
    let v5 = vec![1, 2, 3];
    for i in &v5 {
        println!("{}", i);
    }

    // 可以在迭代过程中，修改 Vector 中的元素
    let mut v6 = vec![1, 2, 3];
    for i in &mut v6 {
        *i += 10;
        println!("{}", i);
    }

    // 存储不同类型的元素
}
